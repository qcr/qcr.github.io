{"pageProps":{"codeData":{"content":"<p><strong>NOTE: this software is part of the BenchBot software stack, and not intended to be run in isolation (although it can be installed independently through pip if desired). For a working BenchBot system, please install the BenchBot software stack by following the instructions <a href=\"https://github.com/qcr/benchbot\">here</a>.</strong></p>\n<h1>BenchBot Add-ons Manager</h1>\n<p><a href=\"http://benchbot.org\"><picture><img alt=\"BenchBot project\" src=\"https://img.shields.io/badge/collection-BenchBot-%231a2857\"></picture></a>\n<a href=\"https://qcr.github.io\"><picture><img alt=\"QUT Centre for Robotics Open Source\" src=\"https://github.com/qcr/qcr.github.io/raw/master/misc/badge.svg\"></picture></a>\n<picture><img alt=\"Primary language\" src=\"https://img.shields.io/github/languages/top/qcr/benchbot_addons\"></picture>\n<a href=\"./LICENSE.txt\"><picture><img alt=\"License\" src=\"https://img.shields.io/github/license/qcr/benchbot_addons\"></picture></a></p>\n<p><video autoplay=\"\" muted=\"\" loop=\"\" poster=\"/_next/static/images/benchbot_addons-39bf0e168760909371d48341ec57fbad.webp\"><source src=\"/_next/static/images/benchbot_addons-39bf0e168760909371d48341ec57fbad.webm\" type=\"video/webm\"><source src=\"/_next/static/images/benchbot_addons-39bf0e168760909371d48341ec57fbad.mp4\" type=\"video/mp4\">Sample of all the different add-ons available</video></p>\n<p>The BenchBot Add-ons Manager allows you to use BenchBot with a wide array of additional content, and customise your installation to suite your needs. Semantic Scene Understanding not your thing? Install the Semantic Question Answering add-ons instead. Want to create your own content? Write some basic YAML files to make your own add-ons. Need to re-use existing content? Simply include a dependency on that add-on. Add-ons are all about making BenchBot whatever you need it to beâ€”build a BenchBot for your research problems, exactly as you need it.</p>\n<p>Add-ons come in a variety of types. Anything that you may need to customise for your own experiments or research, should be customisable through an add-on. If not, let us know, and we'll add more add-on enabled functionality to BenchBot!</p>\n<p>The list of currently supported types of add-ons are:</p>\n<ul>\n<li><strong>batches</strong>: a list of environments used for repeatable evaluation scores with the <code>benchbot_batch</code> script.</li>\n<li><strong>environments</strong>: simulated or real world environments that a task can be performed in, with a robot. Only <a href=\"https://developer.nvidia.com/Isaac-sim\">Isaac Sim</a> simulation is currently supported, but there is capacity to support other simulators. Please get in contact if you'd like to see another simulator in BenchBot!</li>\n<li><strong>evaluation_methods</strong>: a method for evaluating a set of formatted results, against a corresponding ground truth, and producing scores describing how well a result performed a given task.</li>\n<li><strong>formats</strong>: formalisation of a format for results or ground truth data, including helper functions.</li>\n<li><strong>ground_truths</strong>: ground truth data in a declared format, about a specific environment. Environments can have many different types of ground truths depending on what different tasks require.</li>\n<li><strong>robots</strong>: a robot definition declaring the communication channels available to the BenchBot ecosystem. Both simulated and real world robots are supported, they just need to run ROS.</li>\n<li><strong>tasks</strong>: a task is a definition of something we want a robot to do, including what observations and actions it has available, and how results should be reported.</li>\n</ul>\n<p>See the sections below for details of how to interact with installed add-ons, how to create your own add-ons, and formalisation of what's required in an add-on.</p>\n<h2>Installing and using the add-ons manager</h2>\n<p>In general, you won't use the add-ons manager directly. Instead you interact with the <a href=\"https://github.com/qcr/benchbot\">BenchBot software stack</a>, which uses the add-ons manager to manage and access add-ons.</p>\n<p>The manager is a Python package if you do find you want to use it directly, and installable with pip. Run the following in the root directory where the repository was cloned:</p>\n<pre><code>u@pc:~$ pip install .\n</code></pre>\n<p>The manager can then be imported and used to manage installation, loading, accessing, processing, and updating of add-ons. Some samples of supported functionality are shown below:</p>\n<pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">from</span> benchbot_addons <span class=\"token keyword\">import</span> manager <span class=\"token keyword\">as</span> bam\n\n<span class=\"token comment\"># Check if example with 'name' = 'hello_scd' exists</span>\nbam<span class=\"token punctuation\">.</span>exists<span class=\"token punctuation\">(</span><span class=\"token string\">'examples'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">(</span><span class=\"token string\">'name'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'hello_scd'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># Find all installed environments</span>\nbam<span class=\"token punctuation\">.</span>find_all<span class=\"token punctuation\">(</span><span class=\"token string\">'environments'</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># Get a list of the names for all installed tasks</span>\nbam<span class=\"token punctuation\">.</span>get_field<span class=\"token punctuation\">(</span><span class=\"token string\">'tasks'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'name'</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># Get a list of (name, variant) pairs for all installed environments</span>\nbam<span class=\"token punctuation\">.</span>get_fields<span class=\"token punctuation\">(</span><span class=\"token string\">'environments'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'name'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'variant'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># Find a robot with 'name' = 'carter'</span>\nbam<span class=\"token punctuation\">.</span>get_match<span class=\"token punctuation\">(</span><span class=\"token string\">'robots'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">(</span><span class=\"token string\">'name'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'carter'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># Get the 'results_format' value for the task called 'scd:passive:ground_truth'</span>\nbam<span class=\"token punctuation\">.</span>get_value_by_name<span class=\"token punctuation\">(</span><span class=\"token string\">'tasks'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'scd:passive:ground_truth'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'results_format'</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># Load YAML data for all installed ground truths</span>\nbam<span class=\"token punctuation\">.</span>load_yaml_list<span class=\"token punctuation\">(</span>bam<span class=\"token punctuation\">.</span>find_all<span class=\"token punctuation\">(</span><span class=\"token string\">'ground_truths'</span><span class=\"token punctuation\">,</span> extension<span class=\"token operator\">=</span><span class=\"token string\">'json'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># Install a list of comma-separated add-ons</span>\nbam<span class=\"token punctuation\">.</span>install_addons<span class=\"token punctuation\">(</span><span class=\"token string\">'benchbot-addons/ssu,benchbot-addons/sqa'</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># Install a specific add-on (&amp; it's dependencies)</span>\nbam<span class=\"token punctuation\">.</span>install_addon<span class=\"token punctuation\">(</span><span class=\"token string\">'tasks_ssu'</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># Print the list of currently installed add-ons, &amp; officially available add-ons</span>\nbam<span class=\"token punctuation\">.</span>print_state<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># Uninstall all add-ons</span>\nbam<span class=\"token punctuation\">.</span>remove_addons<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\"># Uninstall a string separated list of add-ons</span>\nbam<span class=\"token punctuation\">.</span>remove_addon<span class=\"token punctuation\">(</span><span class=\"token string\">'benchbot-addons/ssu,benchbot-addons/sqa'</span><span class=\"token punctuation\">)</span>\n</code></pre>\n<h2>Creating your own add-on content</h2>\n<p>Add-ons are designed to make it easy to add your own local content to a BenchBot installation. You can add your own local content to the \"local add-ons\" folder provided with your install. The location on your machine can be printed via the following:</p>\n<pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">from</span> benchbot_addons <span class=\"token keyword\">import</span> manager <span class=\"token keyword\">as</span> bam\n\n<span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>bam<span class=\"token punctuation\">.</span>local_addon_path<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n</code></pre>\n<p>BenchBot expects add-on content to be in named folders denoting the type of content. For example, robots must be in a folder called <code>'robots'</code>, tasks in a folder called <code>'tasks'</code>, and so on. A list of valid content types is available via the <code>SUPPORTED_TYPES</code> field in the add-ons manager.</p>\n<p>Below is an example of the process you would go through to create your own custom task locally:</p>\n<ol>\n<li>Find the location for your custom local add-ons:<pre><code>u@pc:~$ python3 -c 'from benchbot_addons import manager as bam; print(bam.local_addon_path())'\n/home/ben/repos/benchbot/addons/benchbot_addons/.local/my_addons\n</code></pre>\n</li>\n<li>Create the following YAML file for your task: <code>/home/ben/repos/benchbot/addons/benchbot_addons/.local/my_addons/tasks/my_task.yaml</code></li>\n<li>Use the fields described below in the <a href=\"#task-add-ons\">task add-ons specification</a> to define your task</li>\n<li>Save the file</li>\n</ol>\n<p>Done. Your new custom task should now be available for use in your BenchBot system (e.g. <a href=\"https://github.com/qcr/benchbot\"><code>benchbot_run --list-tasks</code></a>).</p>\n<h2>Sharing your custom add-ons</h2>\n<p>Custom add-on content can be grouped together into an add-on package, of which there are two different types: 'official' and third-party.</p>\n<p>'Official' packages are those we've verified, and are stored in our <a href=\"https://github.com/benchbot-addons\">benchbot-addons</a> GitHub organisation. You can get a full list of official add-on packages through the <code>manager.official_addons()</code> helper function, or <code>benchbot_install --list-addons</code> script in the <a href=\"https://github.com/qcr/benchbot\">BenchBot software stack</a>.</p>\n<p>Third-party add-on packages differ only in that we haven't looked at them, and they can be hosted anywhere on GitHub you please.</p>\n<p>Creating all add-on packages is exactly the same process, the only difference is whether the repository is inside or outside of the <a href=\"https://github.com/benchbot-addons\">benchbot-addons</a> GitHub organisation:</p>\n<ol>\n<li>Create a new GitHub repository</li>\n<li>Add folders corresponding to the type of content your add-ons provide (i.e. an environments add-on has an <code>environments</code> directory at the root).</li>\n<li>Add YAML / JSON files for your content, and make sure they match the corresponding format specification from the section below</li>\n<li>Add in any extra content your add-on may require: Python files, simulator binaries, images, etc. (if your add-on gets too big for a Git repository, you can zip the content up, host it somewhere, and use the <code>.remote</code> metadata file described in the next section)</li>\n<li>Decide if your package has any dependencies, and declare them using the appropriate <code>.dependencies*</code> files</li>\n<li>Push everything up to GitHub on your default branch</li>\n</ol>\n<p><em><strong>Note:</strong> it's a good idea to only include one type of add-on per repository as it makes your add-on package more usable for others. It's not a hard rule though, so feel free to add multiple folders to your add-on if you require.</em></p>\n<p>Feel free to have a look at any of the <a href=\"https://github.com/benchbot-addons\">official add-ons</a> for help and examples of how to work with add-ons.</p>\n<h2>Add-ons format specification</h2>\n<p>Here are the technical details of what's expected in add-on content. The BenchBot system will assume these specifications are adhered to, and errors can be expected if you try to use add-ons that don't match the specifications.</p>\n<p>An add-on package has the following structure (technically none of the files are required, they just determine what functionality your add-on includes):</p>\n<table>\n<thead>\n<tr>\n<th>Filename</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>.dependencies</code></td>\n<td>A list of add-on packages that must be installed with this package. Packages are specified by their GitHub identifier (i.e. <code>github_username/repository_name</code>), with one per line</td>\n</tr>\n<tr>\n<td><code>.dependencies-python</code></td>\n<td>A list of Python dependencies for your add-on. Syntax for file is exactly the same as <a href=\"https://pip.pypa.io/en/stable/user_guide/#requirements-files\"><code>requirements.txt</code></a> files.</td>\n</tr>\n<tr>\n<td><code>.remote</code></td>\n<td>Specifies content that should be installed from a remote URL, rather than residing in this repository. A remote resource is specified as a URL and target directory separated by a space. One resource is specified per line. The add-ons manager will fetch the URL specified, and extract the contents to the target directory (e.g. <code>http://myhost/my_content.zip environments</code>)</td>\n</tr>\n<tr>\n<td><code>&lt;directory&gt;/</code></td>\n<td>Each named directory corresponds to an add-on type described below. The directory will be ignored if its name doesn't exactly match any of those below.</td>\n</tr>\n</tbody>\n</table>\n<h3>Batch add-ons</h3>\n<p>A YAML file, that must exist in a folder called <code>batches</code> in the root of the add-on package (e.g. <code>batches/my_batch.yaml</code>).</p>\n<p>The following keys are supported for batch add-ons:</p>\n<table>\n<thead>\n<tr>\n<th>Key</th>\n<th>Required</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>'name'</code></td>\n<td>Yes</td>\n<td>A string used to refer to this batch (must be unique!).</td>\n</tr>\n<tr>\n<td><code>'environments'</code></td>\n<td>Yes</td>\n<td>A list of environment strings of the format <code>'name':'variant'</code> (e.g. <code>'miniroom:1'</code>).</td>\n</tr>\n</tbody>\n</table>\n<h3>Environment add-ons</h3>\n<p>A YAML file, that must exist in a folder called <code>environments</code> in the root of the add-on package (e.g. <code>environments/my_environment.yaml</code>).</p>\n<p>The following keys are supported for environment add-ons:</p>\n<table>\n<thead>\n<tr>\n<th>Key</th>\n<th>Required</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>'name'</code></td>\n<td>Yes</td>\n<td>A string used to refer to this environment's name (the <code>('name', 'variant')</code> pair must be unique!).</td>\n</tr>\n<tr>\n<td><code>'variant'</code></td>\n<td>Yes</td>\n<td>A string used to refer to this environment's variant (the <code>('name', 'variant')</code> pair must be unique!).</td>\n</tr>\n<tr>\n<td><code>'type'</code></td>\n<td>Yes</td>\n<td>A string describing the type of this environment (<code>'sim_unreal'</code> &amp; <code>'real'</code> are the only values currently used).</td>\n</tr>\n<tr>\n<td><code>'map_path'</code></td>\n<td>Yes</td>\n<td>A path to the map for this environment, which will be used by either the simulator or real world system to load the environment.</td>\n</tr>\n<tr>\n<td><code>'start_pose'</code></td>\n<td>Yes</td>\n<td>The start pose of the robot that will be provided to users through the <a href=\"https://github.com/qcr/benchbot_api\">BenchBot API</a>. The pose is specified as a list of 7 numbers: quarternion_w, quarternion_x, quarternion_y, quarternion_z, position_x, position_y, position_z. This must be accurate!</td>\n</tr>\n<tr>\n<td><code>'trajectory_poses'</code></td>\n<td>No</td>\n<td>A list of poses for the robot to traverse through in order. Each pose is a list of 7 numbers: quarternion_w, quarternion_x, quarternion_y, quarternion_z, position_x, position_y, position_z. This environment won't be usable for tasks that use the <code>'move_next'</code> action if this parameter isn't provided.</td>\n</tr>\n<tr>\n<td><code>'robots'</code></td>\n<td>No</td>\n<td>A list of supported names for robot that are supported in this environment. If this list isn't included, all robots with the same <code>'type'</code> as this environment will be able to run.</td>\n</tr>\n<tr>\n<td><code>'object_labels'</code></td>\n<td>No</td>\n<td>A list of labels for the objects that exist in the scene. Can be used with simulated sensors like segmentation sensors.</td>\n</tr>\n</tbody>\n</table>\n<h3>Evaluation method add-ons</h3>\n<p>A YAML file, that must exist in a folder called <code>evaluation_methods</code> in the root of the add-on package (e.g. <code>evaluation_methods/my_evaluation_method.yaml</code>).</p>\n<p>The following keys are supported for evaluation method add-ons:</p>\n<table>\n<thead>\n<tr>\n<th>Key</th>\n<th>Required</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>'name'</code></td>\n<td>Yes</td>\n<td>A string used to refer to this evaluation method (must be unique!)</td>\n</tr>\n<tr>\n<td><code>'valid_result_formats'</code></td>\n<td>Yes</td>\n<td>List of strings denoting results formats supported by the evaluation method. Ideally these format definitions should also be installed.</td>\n</tr>\n<tr>\n<td><code>'valid_ground_truth_formats'</code></td>\n<td>Yes</td>\n<td>List of strings denoting ground truth formats supported by the evaluation method. Ideally these format definitions should also be installed.</td>\n</tr>\n<tr>\n<td><code>'functions'</code></td>\n<td>Yes</td>\n<td>Dictionary of named functions provided by the evaluation method. The named methods are key value pairs where the key is the function name, and the value is a string describing how the function can be imported with Python. For example, <code>evaluate: \"omq.evaluate_method\"</code> declares a function called <code>'evaluate'</code> that is imported via <code>from omq import evaluate_method</code>. Likewise <code>\"omq.submodule.combine_method\"</code> translates to <code>from omq.submodule import combine_method</code>. See below for the list of functions expected for evaluation methods.</td>\n</tr>\n<tr>\n<td><code>'description'</code></td>\n<td>No</td>\n<td>A string describing what the evaluation method is and how it works. Should be included if you want users to understand where your method can be used.</td>\n</tr>\n</tbody>\n</table>\n<p>Evaluation methods expect the following named functions:</p>\n<table>\n<thead>\n<tr>\n<th>Name</th>\n<th>Signature</th>\n<th>Usage</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>'evaluate'</code></td>\n<td><code>fn(dict: results, list: ground_truths) -&gt; dict</code></td>\n<td>Evaluates the performance using a <code>results</code> dictionary, and returns a dictionary of containing the scores. It also takes a list of dictionaries containing each ground truth that will be used in evaluation.</td>\n</tr>\n<tr>\n<td><code>'combine'</code></td>\n<td><code>fn(list: scores) -&gt; dict</code></td>\n<td>Takes a list of <code>scores</code> dictionaries, and returns an aggregate score. If this method isn't declared, <a href=\"https://github.com/qcr/benchbot_eval\"><code>benchbot_eval</code></a> won't return a summary score.</td>\n</tr>\n</tbody>\n</table>\n<h3>Example method add-ons</h3>\n<p>A YAML file, that must in a folder called <code>examples</code> in the root of the add-on package (e.g. <code>examples/my_example.yaml</code>).</p>\n<p>The following keys are supported for example add-ons:</p>\n<table>\n<thead>\n<tr>\n<th>Key</th>\n<th>Required</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>name</code></td>\n<td>Yes</td>\n<td>A string used to refer to this example (must be unique!)</td>\n</tr>\n<tr>\n<td><code>native_command</code></td>\n<td>Yes</td>\n<td>A string describing the command used to run your example natively, relative to the directory of this YAML file! For example running your <code>my_example.py</code> file which is in the same director as this YAML would be <code>python3 ./my_example.py</code>.</td>\n</tr>\n<tr>\n<td><code>container_directory</code></td>\n<td>No</td>\n<td>Directory to be used for Docker's build context. The submission process will automatically look for a file called <code>Dockerfile</code> in that directory unless the <code>'container_filename'</code> key is also provided.</td>\n</tr>\n<tr>\n<td><code>container_filename</code></td>\n<td>No</td>\n<td>Custom filename for your example's Dockerfile. <code>Dockerfile</code> in <code>container_directory</code> will be used if this key is not included. This path is relative to this YAML file, <strong>not</strong> <code>'container_directory'</code>.</td>\n</tr>\n<tr>\n<td><code>description</code></td>\n<td>No</td>\n<td>A string describing what the example is and how it works. Should be included if you want users to understand how your example can be expanded.</td>\n</tr>\n</tbody>\n</table>\n<h3>Format definition add-ons</h3>\n<p>A YAML file, that must exist in a folder called <code>formats</code> in the root of the add-on package (e.g. <code>formats/my_format.yaml</code>).</p>\n<p>The following keys are supported for format add-ons:</p>\n<table>\n<thead>\n<tr>\n<th>Key</th>\n<th>Required</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>'name'</code></td>\n<td>Yes</td>\n<td>A string used to refer to this format (must be unique!)</td>\n</tr>\n<tr>\n<td><code>'functions'</code></td>\n<td>Yes</td>\n<td>Dictionary of named functions for use with this format. The named methods are key-value pairs where the key is the function name, and the value is a string describing how the function can be imported with Python. For example, <code>create: \"object_map.create_empty\"</code> declares a function called <code>'create'</code> that is imported via <code>from object_map import create_empty</code>. Likewise <code>\"object_map.submodule.validate\"</code> translates to <code>from object_map.submodule import validate</code>. See below for the list of functions expected for format definitions.</td>\n</tr>\n<tr>\n<td><code>'description'</code></td>\n<td>No</td>\n<td>A string describing what the format is and how it works. Should be included if you want users to understand what your format is supposed to capture.</td>\n</tr>\n</tbody>\n</table>\n<p>Format definitions expect the following named functions:</p>\n<table>\n<thead>\n<tr>\n<th>Name</th>\n<th>Signature</th>\n<th>Usage</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>'create'</code></td>\n<td><code>fn() -&gt; dict</code></td>\n<td>Function that returns an empty instance of this format. As much as possible should be filled in to make it easy for users to create valid instances (especially when a format is used for results).</td>\n</tr>\n<tr>\n<td><code>'validate'</code></td>\n<td><code>fn(dict: instance) -&gt; None</code></td>\n<td>Takes a proposed <code>instance</code> of this format and validates whether it meets the requirements. Will typically use a series of assert statements to confirm fields are valid.</td>\n</tr>\n</tbody>\n</table>\n<h3>Ground truth add-ons</h3>\n<p>A JSON file, that must exist in a folder called <code>ground_truths</code> in the root of the add-on package (e.g. <code>ground_truths/my_ground_truth.json</code>).</p>\n<p>The following keys are supported for ground truth add-ons:</p>\n<table>\n<thead>\n<tr>\n<th>Key</th>\n<th>Required</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>'environment'</code></td>\n<td>Yes</td>\n<td>A dictionary containing the definition data for the ground truth's reference environment. The data in this field should be a direct copy of an environment add-on.</td>\n</tr>\n<tr>\n<td><code>'format'</code></td>\n<td>Yes</td>\n<td>A dictionary containing the definition data for the ground truth's format. The data in this field should be a direct copy of a format definition add-on.</td>\n</tr>\n<tr>\n<td><code>'ground_truth'</code></td>\n<td>Yes</td>\n<td>A valid instance of the format described by the <code>'format'</code> field. This is where your actual ground truth data should be stored.</td>\n</tr>\n</tbody>\n</table>\n<p>A lot of these keys should be copied from other valid definitions. Please see the <code>GroundTruthCreator</code> helper class in <a href=\"https://github.com/qcr/benchbot_eval\">BenchBot Evaluation</a> for assistance in creating valid ground truths.</p>\n<h3>Robot add-ons</h3>\n<p>A YAML file, that must exist in a folder called <code>robots</code> in the root of the add-on package (e.g. <code>robots/my_robot.yaml</code>).</p>\n<p>The following keys are supported for robot add-ons:</p>\n<table>\n<thead>\n<tr>\n<th>Key</th>\n<th>Required</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>'name'</code></td>\n<td>Yes</td>\n<td>A string used to refer to this robot (must be unique!).</td>\n</tr>\n<tr>\n<td><code>'type'</code></td>\n<td>Yes</td>\n<td>A string describing the type of this robot (<code>'sim_unreal'</code> &amp; <code>'real'</code> are the only values currently used).</td>\n</tr>\n<tr>\n<td><code>'address'</code></td>\n<td>Yes</td>\n<td>A string for the address where a running <a href=\"https://github.com/qcr/benchbot_robot_controller\">BenchBot Robot Controller</a> can be accessed (e.g. <code>'localhost:10000'</code>)</td>\n</tr>\n<tr>\n<td><code>'global_frame'</code></td>\n<td>Yes</td>\n<td>The name of the global TF frame. All poses reported by the <a href=\"https://github.com/qcr/benchbot_api\">BenchBot API</a> will be with respect to this frame.</td>\n</tr>\n<tr>\n<td><code>'robot_frame'</code></td>\n<td>Yes</td>\n<td>The name of the robot's TF frame.</td>\n</tr>\n<tr>\n<td><code>'poses'</code></td>\n<td>Yes</td>\n<td>A list of named poses that this robot provides. This list of poses will be available in observations provided by the <a href=\"https://github.com/qcr/benchbot_api\">BenchBot API</a>.</td>\n</tr>\n<tr>\n<td><code>persistent_cmds</code></td>\n<td>Yes</td>\n<td>A list of commands that will be run and kept alive for the lifetime of the robot controller. The commands will be run in parallel, and executed via <code>bash -c &lt;your_command_string&gt;</code></td>\n</tr>\n<tr>\n<td><code>persistent_status</code></td>\n<td>Yes</td>\n<td>A command used to check the status of your <code>persistent_cmds</code>. This command should execute quickly, and terminate on completion, with the return code being used to evaluate the status. The command string is executed via <code>bash -c &lt;your_command_string&gt;</code></td>\n</tr>\n<tr>\n<td><code>run_cmd</code></td>\n<td>Yes</td>\n<td>A single command issued by the controller to run a simulation. This command must terminate on completion. The command string is executed via <code>bash -c &lt;your_command_string&gt;</code></td>\n</tr>\n<tr>\n<td><code>stop_cmd</code></td>\n<td>Yes</td>\n<td>A single command issued by the controller to stop a simulation. This command must terminate on completion. The command string is executed via <code>bash -c &lt;your_command_string&gt;</code></td>\n</tr>\n<tr>\n<td><code>'connections'</code></td>\n<td>Yes</td>\n<td>A dictionary of connections that your robot makes available to the BenchBot ecosystem. The name of the key-value pair is important, and should follow the recommendations provided on standard channels in the <a href=\"https://github.com/qcr/benchbot_api\">BenchBot API documentation</a>. A description of connection definitions is provided below.</td>\n</tr>\n</tbody>\n</table>\n<p>Connections are the lifeblood of interaction between BenchBot and robot platforms. They are defined by named entries, with the following fields:</p>\n<table>\n<thead>\n<tr>\n<th>Key</th>\n<th>Required</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>'connection'</code></td>\n<td>Yes</td>\n<td>Connection type string, used by the <a href=\"https://github.com/qcr/benchbot_robot_controller\">BenchBot Robot Controller</a>. Supported values are <code>'api_to_ros'</code> (used for actions), <code>'ros_to_api'</code> (used for observations), and <code>'roscache_to_api'</code> (special value used for caching observation values).</td>\n</tr>\n<tr>\n<td><code>'ros_topic'</code></td>\n<td>Yes</td>\n<td>Topic name for the ROS side of the connection.</td>\n</tr>\n<tr>\n<td><code>'ros_type'</code></td>\n<td>Yes</td>\n<td>Topic type for the ROS side of the connection.</td>\n</tr>\n<tr>\n<td><code>'callback_api'</code></td>\n<td>No</td>\n<td>A callback that is run on the HTTP encoded data received / sent on the API end of the connection. It takes in data, and returns transformed data based on the callback's action. Callbacks are specified by a string denoting how the callback can be accessed (e.g. <code>'api_callbacks.convert_to_rgb</code> = <code>from api_callbacks import convert_to_rgb</code>). No data transformation occurs if no callback is provided.</td>\n</tr>\n<tr>\n<td><code>'callback_ros'</code></td>\n<td>No</td>\n<td>A callback that is run on the ROS data received / sent on the robot controller end of the connection. It takes in data and a reference to the robot controller. <code>'api_to_ros'</code> connections use this data to act on the robot, whereas <code>'ros_to_api'</code> connections turn this data into a dictionary that can be serialised into HTTP traffic. Callbacks are specified by a string denoting how the callback can be accessed (e.g. <code>'api_callbacks.convert_to_rgb</code> = <code>from api_callbacks import convert_to_rgb</code>). No action occurs at the ROS level if no callback is provided.</td>\n</tr>\n</tbody>\n</table>\n<h3>Task add-ons</h3>\n<p>A YAML file, that must exist in a folder called <code>tasks</code> in the root of the add-on package (e.g. <code>tasks/my_task.yaml</code>).</p>\n<p>The following keys are supported for task add-ons:</p>\n<table>\n<thead>\n<tr>\n<th>Key</th>\n<th>Required</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>'name'</code></td>\n<td>Yes</td>\n<td>A string used to refer to this task (must be unique!).</td>\n</tr>\n<tr>\n<td><code>'actions'</code></td>\n<td>Yes</td>\n<td>A list of named connections to be provided as actions through the <a href=\"https://github.com/qcr/benchbot_api\">BenchBot API</a>. Running this task will fail if the robot doesn't provide these named connections.</td>\n</tr>\n<tr>\n<td><code>'observations'</code></td>\n<td>Yes</td>\n<td>A list of named connections to be provided as observations through the <a href=\"https://github.com/qcr/benchbot_api\">BenchBot API</a>. Running this task will fail if the robot doesn't provide these named connections.</td>\n</tr>\n<tr>\n<td><code>'localisation'</code></td>\n<td>No</td>\n<td>A string describing the level of localisation. Only supported values currently are <code>'ground_truth'</code> and <code>'noisy'</code>. The default value is '<code>ground_truth</code>'.</td>\n</tr>\n<tr>\n<td><code>'results_format'</code></td>\n<td>No</td>\n<td>A string naming the format for results. The format must be installed, as <a href=\"https://github.com/qcr/benchbot_api\">BenchBot API</a> will use the format's functions to provide the user with empty results.</td>\n</tr>\n<tr>\n<td><code>'description'</code></td>\n<td>No</td>\n<td>A string describing what the task is, and how it works. Should be included if you want users to understand what challenges your task is trying to capture.</td>\n</tr>\n<tr>\n<td><code>'type'</code></td>\n<td>No</td>\n<td>A string describing what robot / environment types are valid for this task. For example, a task that provides a magic image segmentation sensor would only be made available for <code>'sim_unreal'</code> type robots / environments.</td>\n</tr>\n<tr>\n<td><code>'scene_count'</code></td>\n<td>No</td>\n<td>Integer representing the number of scenes (i.e. environment variations required for a task). If omitted, a default value of 1 will be used for the task.</td>\n</tr>\n</tbody>\n</table>\n","name":"BenchBot Add-ons Manager","type":"code","url":"https://github.com/qcr/benchbot_addons","image":"./docs/benchbot_addons.gif","_images":["/_next/static/images/benchbot_addons-39bf0e168760909371d48341ec57fbad.webm","/_next/static/images/benchbot_addons-39bf0e168760909371d48341ec57fbad.mp4","/_next/static/images/benchbot_addons-39bf0e168760909371d48341ec57fbad.webp","/_next/static/images/benchbot_addons-39bf0e168760909371d48341ec57fbad.jpg"],"src":"/content/benchbot/benchbot-addons.md","id":"benchbot-addons","image_position":"center"}},"__N_SSG":true}