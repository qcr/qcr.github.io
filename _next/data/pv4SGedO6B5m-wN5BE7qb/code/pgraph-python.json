{"pageProps":{"codeData":{"content":"<h1>PGraph: graphs for Python</h1>\n<p><a href=\"https://github.com/petercorke/robotics-toolbox-python\"><picture><img alt=\"A Python Robotics Package\" src=\"https://raw.githubusercontent.com/petercorke/robotics-toolbox-python/master/.github/svg/py_collection.min.svg\"></picture></a>\n<a href=\"https://github.com/petercorke/spatialmath-python\"><picture><img alt=\"Powered by Spatial Maths\" src=\"https://raw.githubusercontent.com/petercorke/spatialmath-python/master/.github/svg/sm_powered.min.svg\"></picture></a>\n<a href=\"https://qcr.github.io\"><picture><img alt=\"QUT Centre for Robotics Open Source\" src=\"https://github.com/qcr/qcr.github.io/raw/master/misc/badge.svg\"></picture></a></p>\n<p><a href=\"https://pypi.python.org/pypi/pgraph-python/\"><picture><img alt=\"PyPI version fury.io\" src=\"https://badge.fury.io/py/pgraph-python.svg\"></picture></a>\n<a href=\"https://pypi.python.org/pypi/pgraph-python/\"><picture><img alt=\"PyPI pyversions\" src=\"https://img.shields.io/pypi/pyversions/pgraph-python\"></picture></a>\n<a href=\"https://github.com/petercorke/pgraph-python/blob/master/LICENSE\"><picture><img alt=\"GitHub license\" src=\"https://img.shields.io/github/license/Naereen/StrapDown.js.svg\"></picture></a></p>\n<p><a href=\"https://github.com/petercorke/pgraph-python/actions?query=workflow%3Abuild\"><picture><img alt=\"Build Status\" src=\"https://github.com/petercorke/pgraph-python/actions/workflows/master.yml/badge.svg\"></picture></a>\n<a href=\"https://codecov.io/gh/petercorke/pgraph-python\"><picture><img alt=\"Coverage\" src=\"https://codecov.io/gh/petercorke/pgraph-python/branch/master/graph/badge.svg\"></picture></a>\n<picture><img alt=\"pypi downloads\" src=\"https://img.shields.io/pypi/dw/pgraph-python\"></picture></p>\n<ul>\n<li><a href=\"https://github.com/petercorke/pgraph-python\">GitHub repository</a></li>\n<li><a href=\"https://github.com/petercorke/pgraph-python/wiki\">Wiki (examples and details)</a></li>\n<li><a href=\"https://petercorke.github.io/pgraph-python\">Documentation</a></li>\n<li><a href=\"https://github.com/petercorke/pgraph-python/blob/master/CHANGELOG.md\">Changelog</a></li>\n<li>Dependencies: <a href=\"https://numpy.org\"><code>numpy</code></a> <a href=\"https://github.com/bdaiinstitute/spatialmath-python\"><code>spatialmath</code></a></li>\n</ul>\n<p>This Python package allows the manipulation of directed and non-directed graphs.  Also supports embedded graphs.  It is suitable for graphs with thousands of nodes.</p>\n<p><picture><img alt=\"road network\" src=\"https://github.com/petercorke/pgraph-python/raw/master/examples/roads.png\"></picture></p>\n<pre><code>from pgraph import *\nimport json\n\n# load places and routes\nwith open('places.json', 'r') as f:\n    places = json.loads(f.read())\nwith open('routes.json', 'r') as f:\n    routes = json.loads(f.read())\n\n# build the graph\ng = UGraph()\n\nfor name, info in places.items():\n    g.add_vertex(name=name, coord=info[\"utm\"])\n\nfor route in routes:\n    g.add_edge(route[0], route[1], cost=route[2])\n\n# plan a path from Hughenden to Brisbane\np = g.path_Astar('Hughenden', 'Brisbane')\ng.plot(block=False) # plot it\ng.highlight_path(p)  # overlay the path\n</code></pre>\n<h3>Properties and methods of the graph</h3>\n<p>Graphs belong to the class <code>UGraph</code> or <code>DGraph</code> for undirected or directed graphs respectively.  The graph is essentially a container for the vertices.</p>\n<ul>\n<li>\n<p><code>g.add_vertex()</code> add a vertex</p>\n</li>\n<li>\n<p><code>g.n</code> the number of vertices</p>\n</li>\n<li>\n<p><code>g</code> is an iterator over vertices, can be used as <code>for vertex in g:</code></p>\n</li>\n<li>\n<p><code>g[i]</code> reference a vertex by its index or name</p>\n<hr>\n</li>\n<li>\n<p><code>g.add_edge()</code> connect two vertices</p>\n</li>\n<li>\n<p><code>g.edges()</code> all edges in the graph</p>\n</li>\n<li>\n<p><code>g.plot()</code> plots the vertices and edges</p>\n</li>\n<li>\n<p><code>g.nc</code> the number of graph components, 1 if fully connected</p>\n</li>\n<li>\n<p><code>g.component(v)</code> the component that vertex <code>v</code> belongs to</p>\n<hr>\n</li>\n<li>\n<p><code>g.path_BFS()</code> breadth-first search</p>\n</li>\n<li>\n<p><code>g.path_Astar()</code> A* search</p>\n<hr>\n</li>\n<li>\n<p><code>g.adjacency()</code> adjacency matrix</p>\n</li>\n<li>\n<p><code>g.Laplacian()</code> Laplacian matrix</p>\n</li>\n<li>\n<p><code>g.incidence()</code> incidence matrix</p>\n</li>\n</ul>\n<h3>Properties and methods of a vertex</h3>\n<p>Vertices belong to the class <code>UVertex</code> (for undirected graphs) or <code>DVertex</code> (for directed graphs), which are each subclasses of <code>Vertex</code>.</p>\n<ul>\n<li><code>v.coord</code> the coordinate vector for embedded graph (optional)</li>\n<li><code>v.name</code> the name of the vertex (optional)</li>\n<li><code>v.neighbours()</code> is a list of the neighbouring vertices</li>\n<li><code>v1.samecomponent(v2)</code> predicate for vertices belonging to the same component</li>\n</ul>\n<p>Vertices can be named and referenced by name.</p>\n<h3>Properties and methods of an edge</h3>\n<p>Edges are instances of the class <code>Edge</code>.\nEdges are not referenced by the graph object, each edge references a pair of vertices, and the vertices reference the edges.  For a directed graph only the start vertex of an edge references the edge object, whereas for an undirected graph both vertices reference the edge object.</p>\n<ul>\n<li><code>e.cost</code> cost of edge for planning methods</li>\n<li><code>e.next(v)</code> vertex on edge <code>e</code> that is not <code>v</code></li>\n<li><code>e.v1</code>, <code>e.v2</code> the two vertices that define the edge <code>e</code></li>\n</ul>\n<h2>Modifying a graph</h2>\n<ul>\n<li><code>g.remove(v)</code> remove vertex <code>v</code></li>\n<li><code>e.remove()</code> remove edge <code>e</code></li>\n</ul>\n<h2>Subclasing pgraph classes</h2>\n<p>Consider a user class <code>Foo</code> that we would like to connect using a graph <em>overlay</em>, ie.\ninstances of <code>Foo</code> becomes vertices in a graph.</p>\n<ul>\n<li>Have it subclass either <code>DVertex</code> or <code>UVertex</code> depending on graph type</li>\n<li>Then place instances of <code>Foo</code> into the graph using <code>add_vertex</code> and create edges as required</li>\n</ul>\n<pre><code>class Foo(UVertex):\n  # foo stuff goes here\n  \nf1 = Foo(...)\nf2 = Foo(...)\n\ng = UGraph() # create a new undirected graph\ng.add_vertex(f1)\ng.add_vertex(f2)\n\nf1.connect(f2, cost=3)\nfor f in f1.neighbours():\n    # say hi to the neighbours\n</code></pre>\n<h2>Under the hood</h2>\n<p>The key objects and their interactions are shown below.</p>\n<p><picture><img alt=\"data structures\" src=\"https://github.com/petercorke/pgraph-python/raw/master/docs/source/datastructures.png\"></picture></p>\n<h2>MATLAB version</h2>\n<p>This is a re-engineered version of <a href=\"https://github.com/petercorke/spatialmath-matlab/blob/master/PGraph.m\">PGraph.m</a> which ships as part of the <a href=\"https://github.com/petercorke/spatialmath-matlab\">Spatial Math Toolbox for MATLAB</a>.  This class is used to support bundle adjustment, pose-graph SLAM and various planners such as PRM, RRT and Lattice.</p>\n<p>The Python version was designed from the start to work with directed and undirected graphs, whereas directed graphs were a late addition to the MATLAB version.  Semantics are similar but not identical.  In particular the use of subclassing rather than references to\n<em>user data</em> is encouraged.</p>\n","name":"Graph classes (Python)","type":"code","url":"https://github.com/petercorke/pgraph-python","image":"https://github.com/petercorke/pgraph-python/raw/master/examples/roads.png","_images":["/_next/static/images/roads-8b68dd7b635af6f867a02be9d399b4bd.png.webp","/_next/static/images/roads-18739c10c6cf2a6dccbffb581fb9a183.png"],"src":"/content/pgraph-python.md","id":"pgraph-python","image_position":"center"}},"__N_SSG":true}